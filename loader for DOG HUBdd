--NEW UI DOGHUB
const { 
    Client, 
    Events, 
    GatewayIntentBits, 
    REST, 
    Routes, 
    PermissionFlagsBits,
    EmbedBuilder,
    ActionRowBuilder,
    ButtonBuilder,
    ButtonStyle,
    ChannelType
} = require('discord.js');

// Configuration
const CONFIG = {
    TOKEN: process.env.DISCORD_TOKEN || 'YOUR_BOT_TOKEN_HERE',
    CLIENT_ID: process.env.CLIENT_ID || 'YOUR_CLIENT_ID_HERE',
    REQUIRED_ROLE: 'Head Staff'
};

// Validation
if (!CONFIG.TOKEN || CONFIG.TOKEN === 'YOUR_BOT_TOKEN_HERE') {
    console.error('âŒ Please set DISCORD_TOKEN');
    process.exit(1);
}

if (!CONFIG.CLIENT_ID || CONFIG.CLIENT_ID === 'YOUR_CLIENT_ID_HERE') {
    console.error('âŒ Please set CLIENT_ID');
    process.exit(1);
}

// Create client
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages
    ]
});

// Ticket data
const ticketData = {
    active: new Map(), // userId -> Set of channelIds
    channels: new Map(), // channelId -> ticketInfo
    counter: 100
};

// Commands
const commands = [
    {
        name: 'setup',
        description: 'ğŸ« Setup ticket system',
        options: [
            {
                name: 'title',
                description: 'Panel title',
                type: 3,
                required: true
            },
            {
                name: 'color',
                description: 'Embed color (hex code like #FF0000)',
                type: 3,
                required: true
            }
        ]
    }
];

// Register commands
const rest = new REST({ version: '10' }).setToken(CONFIG.TOKEN);

async function deployCommands() {
    try {
        console.log('ğŸ”„ Registering slash commands...');
        
        const data = await rest.put(
            Routes.applicationCommands(CONFIG.CLIENT_ID),
            { body: commands }
        );
        
        console.log(`âœ… Successfully registered ${data.length} commands!`);
    } catch (error) {
        console.error('âŒ Error registering commands:', error);
    }
}

// Helper functions
const utils = {
    hasHeadStaffRole(member) {
        return member.roles.cache.some(role => role.name === CONFIG.REQUIRED_ROLE);
    },

    findTicketCategory(guild) {
        return guild.channels.cache.find(channel => 
            channel.type === ChannelType.GuildCategory && 
            channel.name.toLowerCase() === 'ticket'
        );
    },

    async createTicketCategory(guild) {
        try {
            return await guild.channels.create({
                name: 'Ticket',
                type: ChannelType.GuildCategory,
                permissionOverwrites: [
                    {
                        id: guild.roles.everyone,
                        deny: [PermissionFlagsBits.ViewChannel]
                    }
                ]
            });
        } catch (error) {
            console.error('Error creating ticket category:', error);
            return null;
        }
    }
};

// Bot ready
client.once(Events.ClientReady, async (readyClient) => {
    console.log('\nğŸ‰ ================================');
    console.log(`âœ… Bot is ready!`);
    console.log(`ğŸ¤– ${readyClient.user.tag}`);
    console.log(`ğŸ  ${readyClient.guilds.cache.size} servers`);
    console.log('================================\n');
    
    readyClient.user.setActivity('ğŸ« Ticket System', { type: 'WATCHING' });
    await deployCommands();
});

// Handle slash commands
client.on(Events.InteractionCreate, async (interaction) => {
    if (!interaction.isChatInputCommand()) return;
    
    try {
        if (interaction.commandName === 'setup') {
            await handleSetup(interaction);
        }
    } catch (error) {
        console.error('Error handling command:', error);
        const errorMsg = 'âŒ An error occurred. Please try again.';
        
        if (interaction.deferred || interaction.replied) {
            await interaction.editReply({ content: errorMsg });
        } else {
            await interaction.reply({ content: errorMsg, ephemeral: true });
        }
    }
});

// Setup command handler
async function handleSetup(interaction) {
    // Check if user has HeadStaff role
    if (!utils.hasHeadStaffRole(interaction.member)) {
        return interaction.reply({ 
            content: 'âŒ You need the **Head Staff** role to use this command!', 
            ephemeral: true 
        });
    }
    
    const title = interaction.options.getString('title');
    const colorInput = interaction.options.getString('color');
    
    // Validate color
    const colorRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    if (!colorRegex.test(colorInput)) {
        return interaction.reply({ 
            content: 'âŒ Invalid color format! Use hex color like #FF0000', 
            ephemeral: true 
        });
    }
    
    const embed = new EmbedBuilder()
        .setTitle(title)
        .setDescription('Click the button below to create a support ticket.\n\n' +
                       'ğŸ“ **How to use:**\n' +
                       'â€¢ Click "Create Ticket" button\n' +
                       'â€¢ Wait for the system to create your private channel\n' +
                       'â€¢ Describe your issue or question\n' +
                       'â€¢ Wait for staff response\n\n' +
                       'âš ï¸ **Rules:**\n' +
                       'â€¢ One ticket per person\n' +
                       'â€¢ No spam or misuse\n' +
                       'â€¢ Be patient and respectful')
        .setColor(colorInput)
        .setThumbnail(interaction.guild.iconURL())
        .setFooter({ 
            text: `${interaction.guild.name} â€¢ Ticket System`, 
            iconURL: client.user.avatarURL() 
        })
        .setTimestamp();
    
    const button = new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('create_ticket')
                .setLabel('Create Ticket')
                .setStyle(ButtonStyle.Primary)
                .setEmoji('ğŸ«')
        );
    
    await interaction.reply({ embeds: [embed], components: [button] });
}

// Handle button interactions
client.on(Events.InteractionCreate, async (interaction) => {
    if (!interaction.isButton()) return;
    
    try {
        if (interaction.customId === 'create_ticket') {
            await handleCreateTicket(interaction);
        } else if (interaction.customId === 'close_ticket') {
            await handleCloseTicket(interaction);
        } else if (interaction.customId === 'delete_ticket') {
            await handleDeleteTicket(interaction);
        } else if (interaction.customId === 'reopen_ticket') {
            await handleReopenTicket(interaction);
        }
    } catch (error) {
        console.error('Error handling button:', error);
        const errorMsg = 'âŒ An error occurred. Please try again.';
        
        if (interaction.deferred || interaction.replied) {
            await interaction.editReply({ content: errorMsg });
        } else {
            await interaction.reply({ content: errorMsg, ephemeral: true });
        }
    }
});

// Create ticket handler
async function handleCreateTicket(interaction) {
    const userId = interaction.user.id;
    
    // Check if user already has a ticket
    const userTickets = ticketData.active.get(userId);
    if (userTickets && userTickets.size > 0) {
        const existingTicket = Array.from(userTickets)[0];
        const channel = interaction.guild.channels.cache.get(existingTicket);
        
        if (channel) {
            return interaction.reply({ 
                content: `âŒ You already have an active ticket: ${channel}`, 
                ephemeral: true 
            });
        } else {
            // Channel was deleted, clean up data
            ticketData.active.delete(userId);
            ticketData.channels.delete(existingTicket);
        }
    }
    
    await interaction.deferReply({ ephemeral: true });
    
    try {
        // Find or create ticket category
        let category = utils.findTicketCategory(interaction.guild);
        if (!category) {
            category = await utils.createTicketCategory(interaction.guild);
            if (!category) {
                return interaction.editReply({ 
                    content: 'âŒ Could not create ticket category. Please contact an administrator.' 
                });
            }
        }
        
        const ticketNumber = ++ticketData.counter;
        const channelName = `ticket-${String(ticketNumber).padStart(3, '0')}`;
        
        // Create ticket channel
        const ticketChannel = await interaction.guild.channels.create({
            name: channelName,
            type: ChannelType.GuildText,
            topic: `Ticket #${ticketNumber} | Owner: ${interaction.user.tag} (${interaction.user.id})`,
            parent: category.id,
            permissionOverwrites: [
                {
                    id: interaction.guild.roles.everyone,
                    deny: [PermissionFlagsBits.ViewChannel]
                },
                {
                    id: interaction.user.id,
                    allow: [
                        PermissionFlagsBits.ViewChannel,
                        PermissionFlagsBits.SendMessages,
                        PermissionFlagsBits.ReadMessageHistory,
                        PermissionFlagsBits.AttachFiles,
                        PermissionFlagsBits.EmbedLinks
                    ]
                },
                {
                    id: client.user.id,
                    allow: [
                        PermissionFlagsBits.ViewChannel,
                        PermissionFlagsBits.SendMessages,
                        PermissionFlagsBits.ReadMessageHistory,
                        PermissionFlagsBits.ManageChannels
                    ]
                }
            ]
        });
        
        // Add permissions for HeadStaff role
        const headStaffRole = interaction.guild.roles.cache.find(role => role.name === CONFIG.REQUIRED_ROLE);
        if (headStaffRole) {
            await ticketChannel.permissionOverwrites.create(headStaffRole, {
                ViewChannel: true,
                SendMessages: true,
                ReadMessageHistory: true,
                ManageMessages: true
            });
        }
        
        // Store ticket data
        const ticketInfo = {
            id: ticketNumber,
            ownerId: userId,
            channelId: ticketChannel.id,
            createdAt: new Date(),
            status: 'open' // Track ticket status
        };
        
        ticketData.channels.set(ticketChannel.id, ticketInfo);
        
        if (!ticketData.active.has(userId)) {
            ticketData.active.set(userId, new Set());
        }
        ticketData.active.get(userId).add(ticketChannel.id);
        
        // Send welcome message
        const welcomeEmbed = new EmbedBuilder()
            .setTitle(`ğŸ« Ticket #${String(ticketNumber).padStart(3, '0')}`)
            .setDescription(`Hello ${interaction.user}!\n\n` +
                          'ğŸ“ **Please describe your issue or question in detail**\n' +
                          'â° Staff will respond as soon as possible\n' +
                          'ğŸ“ You can attach files or images if needed\n\n' +
                          '**To close this ticket:**\n' +
                          'â€¢ Only Head Staff can close tickets\n' +
                          'â€¢ Staff will assist you until resolved')
            .setColor('#4CAF50')
            .setThumbnail(interaction.user.avatarURL())
            .addFields(
                { name: 'ğŸ‘¤ Created by', value: interaction.user.tag, inline: true },
                { name: 'ğŸ• Created at', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true },
                { name: 'ğŸ†” Ticket ID', value: `#${String(ticketNumber).padStart(3, '0')}`, inline: true }
            )
            .setFooter({ 
                text: `${interaction.guild.name} â€¢ Ticket System`, 
                iconURL: interaction.guild.iconURL() 
            })
            .setTimestamp();
        
        const closeButton = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('close_ticket')
                    .setLabel('Close Ticket')
                    .setStyle(ButtonStyle.Danger)
                    .setEmoji('ğŸ”’')
            );
        
        await ticketChannel.send({ 
            content: `${interaction.user} **Your ticket has been created!**`, 
            embeds: [welcomeEmbed], 
            components: [closeButton] 
        });
        
        // Notify staff
        if (headStaffRole) {
            const staffEmbed = new EmbedBuilder()
                .setTitle('ğŸ”” New Ticket Created')
                .setDescription(`${interaction.user} has created a new ticket`)
                .setColor('#FFA500')
                .setTimestamp();
            
            await ticketChannel.send({ 
                content: `${headStaffRole}`, 
                embeds: [staffEmbed] 
            });
        }
        
        await interaction.editReply({ 
            content: `âœ… Ticket created successfully! Go to ${ticketChannel} to start chatting.` 
        });
        
        console.log(`ğŸ« New ticket: ${interaction.user.tag} created ticket #${ticketNumber} in ${interaction.guild.name}`);
        
    } catch (error) {
        console.error('Error creating ticket:', error);
        await interaction.editReply({ 
            content: 'âŒ Failed to create ticket. Please try again or contact an administrator.' 
        });
    }
}

// Handle close ticket button (First step - kick user and rename channel)
async function handleCloseTicket(interaction) {
    if (!interaction.channel.name.startsWith('ticket-')) {
        return interaction.reply({ 
            content: 'âŒ This command can only be used in ticket channels!', 
            ephemeral: true 
        });
    }
    
    // Only Head Staff can close tickets
    if (!utils.hasHeadStaffRole(interaction.member)) {
        return interaction.reply({ 
            content: 'âŒ Only **Head Staff** members can close tickets!', 
            ephemeral: true 
        });
    }
    
    const ticketInfo = ticketData.channels.get(interaction.channel.id);
    if (!ticketInfo) {
        return interaction.reply({ 
            content: 'âŒ Ticket data not found!', 
            ephemeral: true 
        });
    }
    
    // Check if ticket is already closed
    if (ticketInfo.status === 'closed') {
        return interaction.reply({ 
            content: 'âŒ This ticket is already closed!', 
            ephemeral: true 
        });
    }
    
    await interaction.deferUpdate();
    
    try {
        // Remove ticket owner's access to the channel
        const ticketOwner = await interaction.guild.members.fetch(ticketInfo.ownerId);
        if (ticketOwner) {
            await interaction.channel.permissionOverwrites.delete(ticketOwner.user.id);
        }
        
        // Rename channel to indicate it's closed
        const newChannelName = interaction.channel.name.replace('ticket-', 'closed-');
        await interaction.channel.setName(newChannelName);
        
        // Update ticket status
        ticketInfo.status = 'closed';
        ticketInfo.closedAt = new Date();
        ticketInfo.closedBy = interaction.user.id;
        ticketData.channels.set(interaction.channel.id, ticketInfo);
        
        // Send closing message with options
        const closeEmbed = new EmbedBuilder()
            .setTitle('ğŸ”’ Ticket Closed')
            .setDescription(`Ticket has been closed by ${interaction.user}\n\n` +
                          `ğŸ“¤ **${ticketOwner ? ticketOwner.user.tag : 'User'} has been removed from this channel**\n\n` +
                          '**Choose an action:**\n' +
                          'ğŸ—‘ï¸ **Delete** - Permanently delete this ticket\n' +
                          'ğŸ”“ **Reopen** - Invite the user back and reopen the ticket')
            .setColor('#FF6B6B')
            .addFields(
                { name: 'ğŸ†” Ticket ID', value: `#${String(ticketInfo.id).padStart(3, '0')}`, inline: true },
                { name: 'ğŸ‘¤ Original Owner', value: ticketOwner ? ticketOwner.user.tag : 'Unknown', inline: true },
                { name: 'ğŸ• Closed At', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true }
            )
            .setFooter({ 
                text: `Closed by ${interaction.user.tag}`, 
                iconURL: interaction.user.avatarURL() 
            })
            .setTimestamp();
        
        const actionButtons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('delete_ticket')
                    .setLabel('Delete Ticket')
                    .setStyle(ButtonStyle.Danger)
                    .setEmoji('ğŸ—‘ï¸'),
                new ButtonBuilder()
                    .setCustomId('reopen_ticket')
                    .setLabel('Reopen Ticket')
                    .setStyle(ButtonStyle.Success)
                    .setEmoji('ğŸ”“')
            );
        
        await interaction.editReply({ 
            embeds: [closeEmbed], 
            components: [actionButtons] 
        });
        
        console.log(`ğŸ”’ Ticket closed: ${interaction.user.tag} closed ticket #${ticketInfo.id} in ${interaction.guild.name}`);
        
    } catch (error) {
        console.error('Error closing ticket:', error);
        await interaction.editReply({ 
            content: 'âŒ Failed to close ticket. Please try again.',
            components: []
        });
    }
}

// Handle delete ticket button
async function handleDeleteTicket(interaction) {
    if (!utils.hasHeadStaffRole(interaction.member)) {
        return interaction.reply({ 
            content: 'âŒ Only **Head Staff** members can delete tickets!', 
            ephemeral: true 
        });
    }
    
    const ticketInfo = ticketData.channels.get(interaction.channel.id);
    if (!ticketInfo) {
        return interaction.reply({ 
            content: 'âŒ Ticket data not found!', 
            ephemeral: true 
        });
    }
    
    await interaction.deferUpdate();
    
    // Clean up data
    ticketData.channels.delete(interaction.channel.id);
    const userTickets = ticketData.active.get(ticketInfo.ownerId);
    if (userTickets) {
        userTickets.delete(interaction.channel.id);
        if (userTickets.size === 0) {
            ticketData.active.delete(ticketInfo.ownerId);
        }
    }
    
    // Send deletion message
    const deleteEmbed = new EmbedBuilder()
        .setTitle('ğŸ—‘ï¸ Deleting Ticket...')
        .setDescription('ğŸ“ Cleaning up data and deleting ticket...\n' +
                       'â° This channel will be deleted in 5 seconds...\n\n' +
                       'ğŸ™ Thank you for using our support system!')
        .setColor('#FF6B6B')
        .setFooter({ text: 'Ticket System' })
        .setTimestamp();
    
    await interaction.editReply({ embeds: [deleteEmbed], components: [] });
    
    console.log(`ğŸ—‘ï¸ Ticket deleted: ${interaction.user.tag} deleted ticket #${ticketInfo.id} in ${interaction.guild.name}`);
    
    setTimeout(async () => {
        try {
            await interaction.channel.delete();
        } catch (error) {
            console.error('Error deleting ticket channel:', error);
        }
    }, 5000);
}

// Handle reopen ticket button
async function handleReopenTicket(interaction) {
    if (!utils.hasHeadStaffRole(interaction.member)) {
        return interaction.reply({ 
            content: 'âŒ Only **Head Staff** members can reopen tickets!', 
            ephemeral: true 
        });
    }
    
    const ticketInfo = ticketData.channels.get(interaction.channel.id);
    if (!ticketInfo) {
        return interaction.reply({ 
            content: 'âŒ Ticket data not found!', 
            ephemeral: true 
        });
    }
    
    await interaction.deferUpdate();
    
    try {
        // Fetch the ticket owner
        const ticketOwner = await interaction.guild.members.fetch(ticketInfo.ownerId);
        
        // Restore ticket owner's permissions
        await interaction.channel.permissionOverwrites.create(ticketOwner.user.id, {
            ViewChannel: true,
            SendMessages: true,
            ReadMessageHistory: true,
            AttachFiles: true,
            EmbedLinks: true
        });
        
        // Rename channel back to original name
        const originalChannelName = interaction.channel.name.replace('closed-', 'ticket-');
        await interaction.channel.setName(originalChannelName);
        
        // Update ticket status
        ticketInfo.status = 'open';
        ticketInfo.reopenedAt = new Date();
        ticketInfo.reopenedBy = interaction.user.id;
        delete ticketInfo.closedAt;
        delete ticketInfo.closedBy;
        ticketData.channels.set(interaction.channel.id, ticketInfo);
        
        // Send reopen message
        const reopenEmbed = new EmbedBuilder()
            .setTitle('ğŸ”“ Ticket Reopened')
            .setDescription(`Ticket has been reopened by ${interaction.user}\n\n` +
                          `âœ… **${ticketOwner.user.tag} has been invited back to this channel**\n\n` +
                          'ğŸ“ You can continue the conversation here.')
            .setColor('#4CAF50')
            .addFields(
                { name: 'ğŸ†” Ticket ID', value: `#${String(ticketInfo.id).padStart(3, '0')}`, inline: true },
                { name: 'ğŸ‘¤ Ticket Owner', value: ticketOwner.user.tag, inline: true },
                { name: 'ğŸ• Reopened At', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true }
            )
            .setFooter({ 
                text: `Reopened by ${interaction.user.tag}`, 
                iconURL: interaction.user.avatarURL() 
            })
            .setTimestamp();
        
        const closeButton = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('close_ticket')
                    .setLabel('Close Ticket')
                    .setStyle(ButtonStyle.Danger)
                    .setEmoji('ğŸ”’')
            );
        
        await interaction.editReply({ 
            content: `${ticketOwner.user} **Welcome back! Your ticket has been reopened.**`,
            embeds: [reopenEmbed], 
            components: [closeButton] 
        });
        
        console.log(`ğŸ”“ Ticket reopened: ${interaction.user.tag} reopened ticket #${ticketInfo.id} in ${interaction.guild.name}`);
        
    } catch (error) {
        console.error('Error reopening ticket:', error);
        await interaction.editReply({ 
            content: 'âŒ Failed to reopen ticket. The user may have left the server.',
            components: []
        });
    }
}

// Handle messages
client.on(Events.MessageCreate, async (message) => {
    if (message.author.bot) return;
    
    // Suggest slash commands for old prefix commands
    if (message.content.startsWith('!')) {
        const embed = new EmbedBuilder()
            .setTitle('âš ï¸ Use Slash Commands')
            .setDescription('This bot uses **Slash Commands** only\n\n' +
                          '**Available commands:**\n' +
                          'â€¢ `/setup` - Setup ticket system\n\n' +
                          'ğŸ’¡ Type `/` to see all commands')
            .setColor('#FFA500')
            .setFooter({ text: 'Use / instead of ! for commands' });
        
        try {
            const reply = await message.reply({ embeds: [embed] });
            setTimeout(() => reply.delete().catch(() => {}), 10000);
        } catch (error) {
            // Ignore errors
        }
    }
});

// Event handlers
client.on(Events.GuildCreate, guild => {
    console.log(`ğŸ‰ Joined server: ${guild.name} (${guild.memberCount} members)`);
});

client.on(Events.GuildDelete, guild => {
    console.log(`ğŸ‘‹ Left server: ${guild.name}`);
});

// Error handling
client.on(Events.Error, error => {
    console.error('âŒ Discord client error:', error);
});

client.on(Events.Warn, warning => {
    console.warn('âš ï¸ Discord warning:', warning);
});

process.on('unhandledRejection', error => {
    console.error('âŒ Unhandled rejection:', error);
});

process.on('uncaughtException', error => {
    console.error('âŒ Uncaught exception:', error);
    process.exit(1);
});

// Auto-cleanup system
setInterval(async () => {
    console.log('ğŸ§¹ Cleaning up system...');
    
    // Clean up tickets with deleted channels
    for (const [channelId, ticketInfo] of ticketData.channels.entries()) {
        const channel = client.channels.cache.get(channelId);
        if (!channel) {
            console.log(`ğŸ—‘ï¸ Removing data for deleted ticket channel: ${channelId}`);
            ticketData.channels.delete(channelId);
            
            const userTickets = ticketData.active.get(ticketInfo.ownerId);
            if (userTickets) {
                userTickets.delete(channelId);
                if (userTickets.size === 0) {
                    ticketData.active.delete(ticketInfo.ownerId);
                }
            }
        }
    }
}, 300000); // Every 5 minutes

// Login
console.log('ğŸš€ Starting Discord Ticket Bot...');
client.login(CONFIG.TOKEN)
    .then(() => {
        console.log('ğŸ”‘ Login successful!');
    })
    .catch(error => {
        console.error('âŒ Login failed:', error);
        process.exit(1);
    });
